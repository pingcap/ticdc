// Copyright 2020 PingCAP, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// See the License for the specific language governing permissions and
// limitations under the License.

package filter

import (
	"sync"

	"github.com/gogo/protobuf/proto"
	"github.com/pingcap/log"
	"github.com/pingcap/ticdc/eventpb"
	bf "github.com/pingcap/ticdc/pkg/binlog-filter"
	"github.com/pingcap/ticdc/pkg/common"
	"github.com/pingcap/ticdc/pkg/config"
	timodel "github.com/pingcap/tidb/pkg/meta/model"
	"github.com/pingcap/tidb/pkg/parser/mysql"
	"github.com/pingcap/tidb/pkg/util/chunk"
	tfilter "github.com/pingcap/tidb/pkg/util/table-filter"
	"go.uber.org/zap"
)

const (
	// SyncPointTable is the table name use to write ts-map when sync-point is enable.
	SyncPointTable = "syncpoint_v1"
	// DDLTsTable is the table name use to write ddl commitTs for each table when downstream is mysql-class
	DDLTsTable = "ddl_ts_v1"

	// TiCDCSystemSchema is the schema only use by TiCDC.
	TiCDCSystemSchema = "tidb_cdc"
	// LightningTaskInfoSchema is the schema only generated by Lightning
	LightningTaskInfoSchema = "lightning_task_info"
	// TiDBWorkloadSchema is the schema that needs to be skipped by TiCDC.
	TiDBWorkloadSchema = "workload_schema"
)

// Filter are safe for concurrent use.
type Filter interface {
	// ShouldIgnoreDML returns true if the DML event should not be handled.
	ShouldIgnoreDML(dmlType common.RowType, preRow, row chunk.Row, tableInfo *common.TableInfo) (bool, error)
	// ShouldIgnoreDDL returns true if the DDL event should not be sent to downstream.
	ShouldIgnoreDDL(schema, table, query string, ddlType timodel.ActionType, tableInfo *timodel.TableInfo) (bool, error)
	// ShouldIgnoreTable returns true if the table should be ignored.
	ShouldIgnoreTable(schema, table string, tableInfo *timodel.TableInfo) bool
	// Verify should only be called by create changefeed OpenAPI.
	// Its purpose is to verify the expression filter config.
	// Verify(tableInfos []*model.TableInfo) error
}

// filter implements Filter.
type filter struct {
	// tableFilter is used to filter in dml/ddl event by table name.
	tableFilter tfilter.Filter
	// dmlExprFilter is used to filter out dml event by its columns value.
	dmlExprFilter *dmlExprFilter
	// sqlEventFilter is used to filter out dml/ddl event by its type or query.
	sqlEventFilter *sqlEventFilter
	// ignoreTxnStartTs is used to filter out dml/ddl event by its starsTs.
	ignoreTxnStartTs []uint64
	forceReplicate   bool
}

// NewFilter creates a filter.
func NewFilter(cfg *config.FilterConfig, tz string, caseSensitive bool, forceReplicate bool) (Filter, error) {
	f, err := VerifyTableRules(cfg)
	if err != nil {
		return nil, err
	}

	if !caseSensitive {
		f = tfilter.CaseInsensitive(f)
	}

	dmlExprFilter, err := newExprFilter(tz, cfg)
	if err != nil {
		return nil, err
	}
	sqlEventFilter, err := newSQLEventFilter(cfg, caseSensitive)
	if err != nil {
		return nil, err
	}
	return &filter{
		tableFilter:      f,
		dmlExprFilter:    dmlExprFilter,
		sqlEventFilter:   sqlEventFilter,
		ignoreTxnStartTs: cfg.IgnoreTxnStartTs,
		forceReplicate:   forceReplicate,
	}, nil
}

// IsEligible returns whether the table is a eligible table.
// A table is eligible if it has a primary key or unique key on not null columns.
// Or when enable forReplicate or the table is a view.
func (f *filter) IsEligible(tableInfo *timodel.TableInfo) bool {
	// Sequence is not supported yet, TiCDC needs to filter all sequence tables.
	// See https://github.com/pingcap/tiflow/issues/4559
	if tableInfo.IsSequence() {
		return false
	}
	if f.forceReplicate {
		return true
	}
	if tableInfo.IsView() {
		return true
	}

	// If the table has primary key, it is eligible.
	for _, col := range tableInfo.Columns {
		if !(col.IsGenerated() && !col.GeneratedStored) { // visible and not stored generated column
			if (tableInfo.PKIsHandle && mysql.HasPriKeyFlag(col.GetFlag())) || col.ID == timodel.ExtraHandleID {
				return true
			}
		}
	}

	// If the table has unique key on not null columns, it is eligible.
	for _, idx := range tableInfo.Indices {
		if idx.Primary {
			return true
		}
		if len(idx.Columns) == 0 {
			continue
		}
		if idx.Unique {
			// ensure all columns in unique key have NOT NULL flag
			allColNotNull := true
			skip := false
			for _, idxCol := range idx.Columns {
				col := timodel.FindColumnInfo(tableInfo.Cols(), idxCol.Name.L)
				// This index has a column in DeleteOnly state,
				// or it is expression index (it defined on a hidden column),
				// it can not be implicit PK, go to next index iterator
				if col == nil || col.Hidden {
					skip = true
					break
				}
				if !mysql.HasNotNullFlag(col.GetFlag()) {
					allColNotNull = false
					break
				}
			}
			if skip {
				continue
			}
			if allColNotNull {
				return true
			}
		}
	}
	return false
}

// ShouldIgnoreDML checks if a DML event should be ignore by conditions below:
// 0. By startTs.
// 1. By table name.
// 2. By type.
func (f *filter) ShouldIgnoreDML(dmlType common.RowType, preRow, row chunk.Row, tableInfo *common.TableInfo) (bool, error) {
	if f.ShouldIgnoreTable(tableInfo.GetSchemaName(), tableInfo.GetTableName(), nil) {
		return true, nil
	}

	ignoreByEventType, err := f.sqlEventFilter.shouldSkipDML(tableInfo.GetSchemaName(), tableInfo.GetTableName(), dmlType)
	if err != nil {
		return false, err
	}
	if ignoreByEventType {
		return true, nil
	}
	return f.dmlExprFilter.shouldSkipDML(dmlType, preRow, row, tableInfo)
}

// ShouldIgnoreDDL checks if a DDL event should be ignore by conditions below:
// 0. By allow list.
// 1. By schema name.
// 2. By table name.
// 3. By startTs.
// 4. By ddl type.
// 5. By ddl query.
func (f *filter) ShouldIgnoreDDL(schema, table, query string, ddlType timodel.ActionType, tableInfo *timodel.TableInfo) (bool, error) {
	if !isAllowedDDL(ddlType) {
		return true, nil
	}

	// If the DDL is a schema DDL, we should ignore it if the schema is not allowed.
	if IsSchemaDDL(ddlType) && (IsSysSchema(schema) || !f.tableFilter.MatchSchema(schema)) {
		return true, nil
	}

	if f.ShouldIgnoreTable(schema, table, tableInfo) {
		return true, nil
	}

	// if f.shouldIgnoreStartTs(ddl.StartTs) {
	// 	return true, nil
	// }
	return f.sqlEventFilter.shouldSkipDDL(schema, table, query, ddlType)
}

// ShouldIgnoreTable returns true if the specified table should be ignored by this changefeed.
// NOTICE: Set `tbl` to an empty string to test against the whole database.
func (f *filter) ShouldIgnoreTable(db, tbl string, tableInfo *timodel.TableInfo) bool {
	if IsSysSchema(db) {
		return true
	}

	if tableInfo != nil && !f.IsEligible(tableInfo) {
		log.Info("table is not eligible, should ignore this table", zap.String("db", db), zap.String("table", tbl))
		return true
	}

	return !f.tableFilter.MatchTable(db, tbl)
}

// func (f *filter) Verify(tableInfos []*model.TableInfo) error {
// 	return f.dmlExprFilter.verify(tableInfos)
// }

func (f *filter) shouldIgnoreStartTs(ts uint64) bool {
	for _, ignoreTs := range f.ignoreTxnStartTs {
		if ignoreTs == ts {
			return true
		}
	}
	return false
}

func isAllowedDDL(actionType timodel.ActionType) bool {
	_, ok := ddlWhiteListMap[actionType]
	return ok
}

// IsSchemaDDL returns true if the action type is a schema DDL.
func IsSchemaDDL(actionType timodel.ActionType) bool {
	switch actionType {
	case timodel.ActionCreateSchema, timodel.ActionDropSchema,
		timodel.ActionModifySchemaCharsetAndCollate:
		return true
	default:
		return false
	}
}

var (
	once    sync.Once
	storage *SharedFilterStorage
)

type FilterWithConfig struct {
	Filter
	config   *eventpb.FilterConfig
	timeZone string
}

type SharedFilterStorage struct {
	// Each dispatcher in the same changefeed will share the same filter storage.
	m     map[common.ChangeFeedID]FilterWithConfig
	mutex sync.Mutex
}

func GetSharedFilterStorage() *SharedFilterStorage {
	once.Do(func() {
		storage = &SharedFilterStorage{
			m: make(map[common.ChangeFeedID]FilterWithConfig),
		}
	})
	return storage
}

func (s *SharedFilterStorage) GetOrSetFilter(
	changeFeedID common.ChangeFeedID,
	cfg *eventpb.FilterConfig,
	timeZone string,
) (Filter, error) {
	s.mutex.Lock()
	defer s.mutex.Unlock()
	if f, ok := s.m[changeFeedID]; ok {
		if !isFilterConfigEqual(f.config, cfg) || f.timeZone != timeZone {
			log.Info("filter config changed, need to rebuild filter", zap.Any("preConfig", f.config), zap.Any("newConfig", cfg), zap.String("preTimeZone", f.timeZone), zap.String("newTimeZone", timeZone))
		} else {
			return f.Filter, nil
		}
	}
	// convert eventpb.FilterConfig to config.FilterConfig
	filterCfg := &config.FilterConfig{
		Rules:            cfg.FilterConfig.Rules,
		IgnoreTxnStartTs: cfg.FilterConfig.IgnoreTxnStartTs,
	}
	for _, rule := range cfg.FilterConfig.EventFilters {
		f := &config.EventFilterRule{
			Matcher:                  rule.Matcher,
			IgnoreSQL:                rule.IgnoreSql,
			IgnoreInsertValueExpr:    rule.IgnoreInsertValueExpr,
			IgnoreUpdateNewValueExpr: rule.IgnoreUpdateNewValueExpr,
			IgnoreUpdateOldValueExpr: rule.IgnoreUpdateOldValueExpr,
			IgnoreDeleteValueExpr:    rule.IgnoreDeleteValueExpr,
		}
		for _, e := range rule.IgnoreEvent {
			f.IgnoreEvent = append(f.IgnoreEvent, bf.EventType(e))
		}

		filterCfg.EventFilters = append(filterCfg.EventFilters, f)
	}
	// generate table filter
	f, err := NewFilter(filterCfg, timeZone, cfg.CaseSensitive, cfg.ForceReplicate)
	if err != nil {
		return nil, err
	}
	s.m[changeFeedID] = FilterWithConfig{
		Filter:   f,
		config:   cfg,
		timeZone: timeZone,
	}
	return f, nil
}

// isFilterConfigEqual compares two FilterConfig for equality by content
func isFilterConfigEqual(cfg1, cfg2 *eventpb.FilterConfig) bool {
	// Fast path: if pointers are equal, configs are definitely equal
	if cfg1 == cfg2 {
		return true
	}

	// Handle nil cases
	if cfg1 == nil || cfg2 == nil {
		return false
	}

	// Use protobuf's built-in Equal method for content comparison
	return proto.Equal(cfg1, cfg2)
}
